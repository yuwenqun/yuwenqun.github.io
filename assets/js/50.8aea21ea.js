(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{353:function(t,n,e){"use strict";e.r(n);var a=e(22),r=Object(a.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"多线程安全问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#多线程安全问题"}},[t._v("#")]),t._v(" 多线程安全问题")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("多线程的安全问题的根本原因是:共享变量\n\n解决方案:代码块/同步方法/锁机制\n")])])]),e("h2",{attrs:{id:"代码块"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#代码块"}},[t._v("#")]),t._v(" 代码块")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('public class buyTicketAsync implements Runnable{\n    public int ticket = 100;  //总的票数\n\n    Object o = new Object();  //共享变量锁，任何一个对象都可以\n\n    @Override\n    public void run() {\n        while (true){\n            synchronized (o){  //核心代码：o代表的是一个锁，只有持有这个锁才能执行块中的代码\n                if (ticket>0){\n                    System.out.println();\n                    System.out.println(Thread.currentThread().getName()+":正在卖出第"+ticket+"张票");\n                    ticket--;\n                }\n            } //块代码结束，o变量被释放\n        }\n    }\n}\n')])])]),e("h2",{attrs:{id:"同步方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#同步方法"}},[t._v("#")]),t._v(" 同步方法")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('public class buyTicketAsyncMethod implements Runnable{\n    public int ticket = 100;\n\n\n    @Override\n    public void run() {\n        while (true){\n            buyTicket();\n        }\n    }\n\n    public synchronized  void buyTicket(){  //方法前加入synchronized代表是同步方法，等效于枷锁\n            if (ticket>0){\n                System.out.println();\n                System.out.println(Thread.currentThread().getName()+":正在卖出第"+ticket+"张票");\n                ticket--;\n            }\n    }\n}\n')])])]),e("h2",{attrs:{id:"锁机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#锁机制"}},[t._v("#")]),t._v(" 锁机制")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('\n\n```import java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class buyTicket implements Runnable{\n    public int ticket = 100;\n    Lock l = new ReentrantLock();  //独占锁\n\n    @Override\n    public void run() {\n        while (true){\n            l.lock();  //加锁\n            if (ticket>0){\n                System.out.println();\n                System.out.println(Thread.currentThread().getName()+":正在卖出第"+ticket+"张票");\n                ticket--;\n            }\n            l.unlock(); //释放锁\n        }\n    }\n}')])])])])}),[],!1,null,null,null);n.default=r.exports}}]);